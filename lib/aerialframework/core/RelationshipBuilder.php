<?php
    import("aerialframework.utils.akelos.Inflector");

    class RelationshipBuilder
    {
        const MANY_TO_MANY = "mn";

        private static $definitions;

        /**
         * Builds custom relationships based on the relationships.xml and
         * the definition of the schema as generated by Doctrine
         *
         * @param array $definitions
         * @return array
         */
        public static function build(array $definitions)
        {
            self::$definitions = $definitions;

            $relationshipsFile = Configuration::get("CONFIG_PATH") . "/relationships.xml";
            if(!file_exists($relationshipsFile))
                return $definitions;

            $relationships = file_get_contents($relationshipsFile);
            if(strlen($relationships) == 0 || empty($relationships))
                return $definitions;

            try
            {
                $relationships = new SimpleXMLElement($relationships, LIBXML_NOCDATA);
            }
            catch(Exception $e)
            {
                throw new Exception("Unable to parse relationships.xml file.\n" .
                    "Error: " . $e->getMessage() . "\n" .
                    "Line: " . $e->getLine() . "\n" .
                    "Code: " . $e->getCode());
            }

            $newRelationships = array();

            foreach($relationships as $element)
            {
                if(empty($element) || !is_a($element, "SimpleXMLElement"))
                    continue;

                $name = $element->getName();
                $parsed = null;

                switch($name)
                {
                    case self::MANY_TO_MANY:
                        $parsed = self::parseManyToMany($element);
                        break;
                }

                if(!empty($parsed))
                    $newRelationships[] = $parsed;
            }

            return $definitions;
        }

        /**
         * Sample format:
         * <mn joinTable="{{TABLE}}">
         *      <table fk="{{FOREIGN_KEY}}">{{TABLE}}</table>
         *      <table fk="{{FOREIGN_KEY}}" alias="{{OPTIONAL_ALIAS}}">{{TABLE}}</table>
         * </mn>
         *
         * @static
         * @param SimpleXMLElement $element
         * @return null
         */
        private static function parseManyToMany(SimpleXMLElement $element)
        {
            if(empty($element))
                return null;

            if(!isset($element["joinTable"]))
                RelationshipException::throwSyntaxException("\"joinTable\" is", null, null, self::MANY_TO_MANY);

            $joinTable = $element["joinTable"];
            $joinTableName = (string) $joinTable;

            if(!isset($element->table))
                RelationshipException::throwSyntaxException("2 <table> nodes are", null, null, self::MANY_TO_MANY);

            $tablesCount = count($element->table);
            if($tablesCount > 2)
                RelationshipException::throwStructureException("More than two tables are not allowed", null, null, self::MANY_TO_MANY);
            else if($tablesCount < 2)
                RelationshipException::throwStructureException("Less than two tables are not allowed", null, null, self::MANY_TO_MANY);

            $definition = array();
            $definition["topLevelRelation"] = array();
            $definition["joinTableRelation"] = array();

            $tables = array();

            foreach($element->table as $table)
            {
                if(!isset($table["fk"]))
                    RelationshipException::throwSyntaxException("<fk> node in <table> is", null, null, self::MANY_TO_MANY);

                $fk = (string) $table["fk"];

                // optional alias
                if(isset($table["alias"]))
                    $alias = (string) $table["alias"];

                $tableName = (string) $table;

                $tables[] = array(
                    "name"  => $tableName,
                    "key"   => $fk,
                    "alias" => $alias
                );
            }

            $primaryTable = $tables[0];
            $secondaryTable = $tables[1];

            // build relation definitions
            $relationAlias = isset($secondaryTable["alias"]) ? $secondaryTable["alias"] : $secondaryTable["name"];

            $definition["topLevelRelation"][$relationAlias] = array();
            $topLevelDef =& $definition["topLevelRelation"][$relationAlias];

            $topLevelDef["local"] = $primaryTable["key"];
            $topLevelDef["foreign"] = $secondaryTable["key"];
            $topLevelDef["foreignAlias"] = isset($primaryTable["alias"]) ? $primaryTable["alias"] : $primaryTable["name"];
            $topLevelDef["class"] = $secondaryTable["name"];
            $topLevelDef["refClass"] = $joinTableName;

            $inflectedJoinAlias = lcfirst(Inflector::pluralize($joinTableName));

            $primaryTablePrimaryKey = self::getTablePrimaryKey($primaryTable["name"]);
            $secondaryTablePrimaryKey = self::getTablePrimaryKey($secondaryTable["name"]);

            if(empty($primaryTablePrimaryKey))
                throw new RelationshipException("Cannot find a primary key for ".$primaryTable["name"]." table");

            if(empty($secondaryTablePrimaryKey))
                throw new RelationshipException("Cannot find a primary key for ".$secondaryTable["name"]." table");

            $joinDef =& $definition["joinTableRelation"];

            $joinDef[$primaryTable["name"]] = array(
                "class" => $primaryTable["name"],
                "local" => $primaryTable["key"],
                "foreign" => $primaryTablePrimaryKey,
                "foreignAlias" => $inflectedJoinAlias
            );

            $joinDef[$secondaryTable["name"]] = array(
                "class" => $secondaryTable["name"],
                "local" => $secondaryTable["key"],
                "foreign" => $secondaryTablePrimaryKey,
                "foreignAlias" => $inflectedJoinAlias
            );

            self::$definitions = self::removeRelationsBetween($primaryTable["name"], $joinTableName);
            self::$definitions = self::removeRelationsBetween($secondaryTable["name"], $joinTableName);

            if(!isset(self::$definitions[$primaryTable["name"]]["relations"]))
                self::$definitions[$primaryTable["name"]]["relations"] = array();

            self::$definitions[$primaryTable["name"]]["relations"][$relationAlias] = $topLevelDef;

            if(!isset(self::$definitions[$joinTableName]["relations"]))
                self::$definitions[$joinTableName]["relations"] = array();

            if(!empty($joinDef))
            {
                foreach($joinDef as $alias => $def)
                {
                    self::$definitions[$joinTableName]["relations"][$alias] = $def;
                }
            }

            return sfYaml::dump(self::$definitions, 6);
        }

        /**
         * Find the column name of the primary key of a given table name
         *
         * @static
         * @param $name
         * @return int|null|string
         */
        private static function getTablePrimaryKey($name)
        {
            $definitions = self::$definitions;

            foreach($definitions as $className => $definition)
            {
                if($name != $className)
                    continue;

                $columns = isset($definition["columns"]) ? $definition["columns"] : null;
                if(empty($columns))
                    continue;

                foreach($columns as $columnName => $columnDefinition)
                {
                    if(!isset($columnDefinition["primary"]) || $columnDefinition["primary"] != "true")
                        continue;

                    return $columnName;
                }
            }

            return null;
        }

        /**
         * Find and remove relationships between two tables
         *
         * @static
         * @param $table1
         * @param $table2
         */
        private static function removeRelationsBetween($table1, $table2)
        {
            $def = self::$definitions;

            if(!isset($def[$table1]))
                throw new RelationshipException("Cannot find table named $table1");

            if(!isset($def[$table2]))
                throw new RelationshipException("Cannot find table named $table2");

            $relations1 = @$def[$table1]["relations"];
            $relations2 = @$def[$table2]["relations"];

            $interRelations1 = self::findRelationsToTable($relations1, $table2);
            $interRelations2 = self::findRelationsToTable($relations2, $table1);

            $relations = array(array("name" => $table1, "relations" => $relations1, "inter" => $interRelations1),
                                array("name" => $table2, "relations" => $relations2, "inter" => $interRelations2));

            foreach($relations as $table)
            {
                if(empty($table["relations"]) || empty($table["inter"]))
                    continue;

                foreach($table["relations"] as $alias => $relation)
                {
                    foreach($table["inter"] as $inter)
                    {
                        if($inter === $relation)
                            unset($def[$table["name"]]["relations"][$alias]);
                    }
                }
            }

            return $def;
        }

        /**
         * Finds relations relating to a given table
         *
         * @static
         * @param $relations
         * @param $table
         * @return null
         */
        private static function findRelationsToTable($relations, $table)
        {
            if(empty($relations) || empty($table))
                return null;

            $interRelations = array();

            foreach($relations as $alias => $relation)
            {
                if(empty($relation))
                    continue;

                if($relation["class"] == $table || $alias == $table)
                    $interRelations[] = $relation;
            }

            return $interRelations;
        }

        /**
         * Sanitize the definition by removing unnecessary nodes
         *
         * @static
         * @param $newDefinitions
         * @return array
         */
        private static function sanitizeDefinitions()
        {
            $definitions =& self::$definitions;
            
            if(empty($definitions))
                return $definitions;

            foreach($definitions as $table => &$definition)
            {
                if(empty($definition))
                    continue;

                // remove empty "relations" nodes
                if(isset($definition["relations"]) && empty($definition["relations"]))
                    unset($definition["relations"]);
            }

            return $definitions;
        }
    }

    class RelationshipException extends Exception
    {
        public static function throwSyntaxException($message, $code, $previous, $section)
        {
            throw new RelationshipException("Syntax error: " . $message . " missing from <$section>", $code, $previous);
        }

        public static function throwStructureException($message, $code, $previous, $section)
        {
            throw new RelationshipException("Structure error: " . $message . " in <$section>", $code, $previous);
        }
    }
